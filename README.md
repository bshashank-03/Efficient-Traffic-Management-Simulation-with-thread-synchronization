# Efficient-Traffic-Management-Simulation-with-thread-synchronization
<p>I modelled a typical traffic scenario in this project, where a flag person is guiding traffic and one lane is closed. There is construction going on on one side of the road, thus all east and westbound traffic must synchronise to go through the area without causing a traffic block or accident.</p>
<p>To effectively coordinate threads, this simulation makes use of synchronisation techniques including semaphores, mutexes, and condition variables. It prevents potential race conditions by safeguarding shared data structures with mutexes and ensures proper car generation through a semaphore-based mechanism. In this project we have also employed a condition variable to manage the flag person's state and utilises proper sleep functions for delay. So basically The project's strengths lie in its effective synchronisation implementation, ensuring thread safety, controlled car production, and flag person coordination. Overall, the project showcases a valuable application of synchronisation techniques in a real-world traffic management scenario.</p>
<ul>
  <li><b>Semaphore: Semaphore_Car</b> <p>This semaphore is used to control the access to the car production threads. It ensures that only one car production thread can generate cars at a time. It is waited upon using sem_wait and released using sem_post.</p></li>
  <li><b>Mutex lock: TrafficPolice_mutex_lock </b> <p>This mutex is used to protect critical sections of code where shared variables and data structures are accessed or modified. It is locked and unlocked using pthread_mutex_lock and pthread_mutex_unlock functions, respectively.</p></li>
  <li><b>Condition Variables: TrafficPolice_Condn</b><p>This condition variable is used to synchronise the flag person thread and the car production threads. It allows the flag person to sleep when there are no cars in both the nReadyQ and sReadyQ queues and wake up when signalled by the car production threads. It is waited upon using pthread_cond_wait and signalled using pthread_cond_signal.</p></li>
  <li><b>Queues: EastBuffer and WestBuffer </b><p>These queues store the cars generated by the car production threads. Access to these queues is protected by the flagPersonMutex. The car consumer thread removes cars from the queues when processing them.</p></li>
</ul>
